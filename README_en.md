# Spleen: Secure Reverse Tunneling & Private Endpoint Tool

Spleen is a reverse tunneling tool written in Go. It is designed to expose private services to the public internet through TLS-encrypted relays in complex network environments. Zero external dependencies, 100% pure Go.

**Typical Use Case**: Expose an internal server (e.g., home NAS, dev machine) without a public IP through a public relay server, enabling access via SSH, HTTP, etc., from anywhere.

## Core Features & Security

Spleen focuses on a streamlined configuration workflow and multi-layered security protections:

*   **Connection Pooling**: Reduces latency via pre-established multiplexed tunnels, eliminating TCP handshake overhead.
*   **Fingerprint Pinning (TOFU)**: Implements a Trust-On-First-Use mechanism to pin server identities, neutralizing Man-in-the-Middle threats.
*   **Full-Chain Encryption**: Enforces TLS 1.2/1.3 for all tunnel traffic to ensure absolute privacy.
*   **Authentication Mechanism**: Uses a Nonce-based challenge-response protocol to prevent replay attacks.
*   **Read-Only Dashboard**: Integrated monitoring UI with a secure read-only design. Configuration changes are made via files (requires service restart to take effect).
*   **Transparent Configuration**: Supports one-click generation of paired JSON configuration files.
*   **Anti-DDoS & Resource Protection**: Built-in connection rate limiting and payload size validation to mitigate memory amplification risks and brute-force attacks.

---

## Quick Start

Docker Compose is recommended for rapid deployment.

### 1. Preparation

Clone the repository on both your **public server** and **internal host**:

```bash
git clone https://github.com/leviathan/spleen.git
cd spleen
```

### 2. Generate Security Token (Recommended on Internal Host)

For maximum security, generate the high-entropy global security token on your **trusted internal machine**:

```bash
docker-compose run --rm spleen-init
```

> [!NOTE]
> This command prints a randomly generated token and exits. The `--rm` flag ensures the temporary container is cleaned up automatically.

### 3. Configure & Start Client (Obtain ClientID)

Since the `client_id` is automatically generated by the client, we need to run it first to get the mapping ID.

1.  **Edit `client-config.json`**:
    *   Set `token` to your generated token.
    *   Set `server_addr` to your public server's IP.
2.  **Start Client**:
    ```bash
    docker-compose up -d spleen-client
    ```
3.  **Obtain ID (Two Methods)**:
    *   **Method 1 (Recommended)**: View the local ID file directly:
        ```bash
        cat data/client/.spleen_client_id
        ```
    *   **Method 2**: Check container logs:
        ```bash
        docker-compose logs --tail=20 spleen-client
        ```

### 4. Configure & Start Public Server

Configure the server using the Token and ClientID obtained earlier:

1.  **Edit `server-config.json`**:
    *   Set `token` to the global token.
    *   Add your `client_id` to the `mapping_rules` section.
    *   (Optional) Change `dashboard_pwd` (default is `admin`).
2.  **Start Server**:
    ```bash
    docker-compose up -d spleen-server
    ```

### 5. Access Dashboard

Navigate to `http://<Public_IP>:54321` to monitor status and mappings.
Note:
- The dashboard is read-only and designed for observation/debugging.
- Mapping lists show both static and active connections but will never expose sensitive tokens.

---

## Configuration Reference

### Server Configuration Example
```json
{
  "token": "your-secret-token", 
  "tunnel_listen_address": "0.0.0.0:5432",
  "panel": {
    "dashboard_addr": "0.0.0.0:54321",
    "dashboard_user": "admin",
    "dashboard_pwd": "pbkdf2$120000$..."
  },
  "mapping_rules": [
    {
      "id": "ssh-main",
      "client_id": "CLIENT_UUID_HERE",
      "public_port": 2222,
      "target_port": 22,
      "remark": "Main SSH Access"
    }
  ]
}
```

**Parameters**:

| Parameter | Description | Example |
|-----------|-------------|---------|
| `token` | **Global Security Token**. Used for challenge-response auth for all connections. | Random string |
| `tunnel_listen_address` | Address where the client connects (TLS). | `0.0.0.0:5432` |
| `panel.dashboard_addr` | Dashboard HTTP listening address. | `0.0.0.0:54321` |
| `panel.dashboard_user` | Dashboard username. | `admin` |
| `panel.dashboard_pwd` | Dashboard password (PBKDF2 hash). | Generate via `-gen-pwd` |
| `mapping_rules` | List of static port forwardings. | See below |

**Mapping Rule Fields**:

| Field | Description | Required |
|-------|-------------|:--------:|
| `id` | Unique identifier for the rule. | ✅ |
| `client_id` | Client UUID (matches client `.spleen_client_id`). | ✅ |
| `public_port` | External port listening on the public server. | ✅ |
| `target_port` | Internal port on the client side. | ✅ |
| `remark` | Optional description. | ❌ |

---

### How to Add More Clients (Multi-Node)

The "One Token" architecture makes it easy to scale horizontally:

1.  **Git Clone**: Clone the repository on your new host: `git clone https://github.com/leviathan/spleen.git`.
2.  **Configure**: Edit `client-config.json` with the shared global `token` and your `server_addr`.
3.  **Start**: Run `docker-compose up -d spleen-client`. It will generate a unique ID automatically.
4.  **Get ID**: Run `cat data/client/.spleen_client_id` to obtain the client's ID.
5.  **Associate**: Add the new `client_id` to your public server's `server-config.json` and restart the server.

---

## Security Recommendations

1.  **Non-Root Execution**: Run Spleen processes as a non-privileged user.
2.  **File Permissions**: Configuration files contain secrets. `spleen-init` sets `0600` automatically. If creating manually, ensure `chmod 600 *.json`.
3.  **Firewall Rules**:
    - Only expose the `tunnel_listen_address` (e.g., 5432) and specifically mapped public ports.

---

## License
[Apache License 2.0](LICENSE)
